template: true
valuesFilePath: ./values.yml

# Template Variables
{{ $IS_CRITICAL_BRANCH := ternary true false (or ( hasPrefix "master" "{{gitBranch}}" ) ( hasPrefix "preRelease" "{{gitBranch}}" ) ( hasPrefix "release" "{{gitBranch}}" ) ( hasPrefix "milestone" "{{gitBranch}}" )) }}
{{ $IS_RELEASE_BRANCH := ternary true false (or ( hasPrefix "preRelease" "{{gitBranch}}" ) ( hasPrefix "release" "{{gitBranch}}" ) ( hasPrefix "milestone" "{{gitBranch}}" )) }}

{{ $TRIGGER_POST_RELEASE := ternary true false $IS_RELEASE_BRANCH }}
{{ $XRAY_SCAN_ENABLED  := ternary true false $IS_CRITICAL_BRANCH }}
# Note. Is overridden & runs on master ever night
{{ $CLAM_SCAN_ENABLED  := ternary true false $IS_RELEASE_BRANCH }}
{{ $QUICK_MODE  := ternary false true $IS_CRITICAL_BRANCH }}
{{ $ARM_BUILD_ENABLED  := ternary true false $IS_RELEASE_BRANCH }}
app_build_node_pool: &app_build_node_pool
                       nodePool: {{ ternary "high_spec_nodes" "pipelines_u20" $ARM_BUILD_ENABLED }}
# Note. Is overridden & runs on master ever night
{{ $TRIGGER_NATIVE_STEPS_MSTEST  := ternary true false $IS_RELEASE_BRANCH }}
#  Sonar is enabled only on development branches
{{ $SONAR_ENABLED := ternary false true $IS_CRITICAL_BRANCH }}
git_resource_trigger_condition: &git_resource_trigger_condition
                                  trigger: {{ ternary false true $IS_CRITICAL_BRANCH }}

pipelines:
  - name: pipelines_build
    configuration:
      retentionPolicy:
        maxAgeDays: 90
        minRuns: 90
      environmentVariables:
        readOnly:
          buildPlaneVersion: "1.55.0"
          CHART_VERSION_OVERRIDE: ""
          dockerVersion: "20.10.9"
          dockerComposeVersion: "1.27.4"
          npmRegistry: "https://entplus.jfrog.io/artifactory/api/npm/npm-virtual"
          repo21: "https://entplus.jfrog.io"
          templateTarget: "pipelines-artifacts/template"
          XRAY_ENABLED: "{{ $XRAY_SCAN_ENABLED }}"
          XRAY_FAIL_PIPELINES: "true"
          CHART_TESTING_IMAGE: releases-docker.jfrog.io/charts-ci
          CHART_TESTING_TAG: 0.1.0
          HELM_VERSION: v3.8.2
          KUBEVAL_VERSION: "0.16.1"
          KUBECTL_VERSION: v1.23.5
          baseMachineImageVersion: "2.7.4"
          QUICK_MODE: "{{ $QUICK_MODE }}"
          CLAM_SCAN_ENABLED: "{{ $CLAM_SCAN_ENABLED }}"
          TRIGGER_POST_RELEASE: "{{ $TRIGGER_POST_RELEASE }}"
          DEPLOY_K8S_ENVIRONMENT: "false"
          SONAR_ENABLED: "{{ $SONAR_ENABLED }}"
          TRIGGER_NATIVE_STEPS_MSTEST: "{{ $TRIGGER_NATIVE_STEPS_MSTEST }}"
          pipeBranch: "{{gitBranch}}"
          ARM_BUILD_ENABLED: "{{ $ARM_BUILD_ENABLED }}"
      jfrogCliVersion: 2
      integrations:
        - name: docker_jfrog_io_reader
        - name: aws_dev_ec2
        - name: entplus_jfrog_io_docker
        - name: entplus_pipelines
        - name: jfdev_agent
        - name: slack_dev_foundation_alerts
        - name: slack_platform_clean_pipeline
        - name: slack_platform_release_pipeline
        - name: jira_jfrog
        - name: security_xray_access_token
      {{ if eq "master" "{{gitBranch}}" }}
      inputResources:
        - name: nightlyBuild
      outputResources:
        - name: CP_buildStatusUpdate
      {{ end }}
    # {{ if eq "master" "{{gitBranch}}" }}
    # postRun:
    #   configuration:
    #    integrations:
    #      - name: entplus_deployer
    #      - name: {{ .Values.statusPage.integration }}
    #   execution:
    #     onExecute:
    #       - task: jfrog/run-status@latest
    #         id: pipelines_master_status
    #         input:
    #           stepFailure: true
    #     onSuccess:
    #       - task: jfrog/update-incident@v0.0.1
    #         id: update_incident
    #         condition: ${OUT_pipe_run_status} == "success"
    #         input:
    #           apiKeysIntegration: {{ .Values.statusPage.integration }}
    #           componentID: {{ .Values.statusPage.componentId }}
    #           pageID: {{ .Values.statusPage.pageId }}
    #     onFailure:
    #       - task: jfrog/create-incident@v0.0.1
    #         id: create_incident
    #         condition: ${OUT_pipe_run_status} == "failure"
    #         input:
    #           apiKeysIntegration: {{ .Values.statusPage.integration }}
    #           componentID: {{ .Values.statusPage.componentId }}
    #           pageID: {{ .Values.statusPage.pageId }}
    # {{ end }}
    steps:
      - name: trigger_controlplane_builds
        type: Bash
        configuration:
          nodePool: pipelines_u20_t3small
          inputResources:
            - name: packagesGit
              trigger: false
          {{ if eq "master" "{{gitBranch}}" }}
            - name: pipelines_master
          {{ end }}
            - name: releasesFile
              <<: *git_resource_trigger_condition
            - name: buildCI
              trigger: false
        execution:
          onStart:
            - |
              if [[ "$QUICK_MODE" == "true" ]]; then
                echo "sending failure update to git because this run was executed in QUICK_MODE"
                update_commit_status packagesGit --status failure --message "marked as failed due to quick mode" --context $step_name
              else
                update_commit_status packagesGit --status success --message "marked as success due to non quick mode" --context $step_name
              fi
            - echo pipelines_master
            - echo $triggeredByResourceName
            - |
              if [ $TRIGGER_NATIVE_STEPS_MSTEST == "true" ]; then
                add_run_variables Enabled_Native_Steps_MSTest="true"
              elif [ {{gitBranch}} == 'master' &&  $triggeredByResourceName == 'nightlyBuild' ]; then
                add_run_variables Enabled_Native_Steps_MSTest="true"
              else
                add_run_variables Enabled_Native_Steps_MSTest="false"
              fi
            - echo "QUICK_MODE - [$QUICK_MODE]"
            - echo "Enabled_Native_Steps_MSTest - [$Enabled_Native_Steps_MSTest]"
            - echo "kicking off all install builds"
            - add_run_variables will_publish_bi="true"
            {{ if eq "master" "{{gitBranch}}" }}
            - write_output "CP_buildStatusUpdate" "runId=${run_id}"
            {{ end }}

      - name: packages_build
        type: Bash
        configuration:
          affinityGroup: packages
          runtime:
            type: image
            image:
              auto:
                language: node
                versions:
                  - "16.10.0"
          integrations:
            - name: entplus_deployer
          inputResources:
            - name: packagesGit
              <<: *git_resource_trigger_condition
          inputSteps:
            - name: trigger_controlplane_builds
        execution:
          onStart:
            - source ${res_packagesGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - npm config set registry ${npmRegistry}
            - export UPDATE_BUILD_STATUS_PACKAGES_BUILD=false
            - pushd "$res_packagesGit_resourcePath"
            - export RT_API_KEY="${int_entplus_deployer_apikey}"
            - export RT_USER="${int_entplus_deployer_user}"
            - export RT_URL="${int_entplus_deployer_url}"
            - cp ${res_packagesGit_resourcePath}/build/ci/npm_installer.sh ./
            - ./npm_installer.sh
            - changedFiles=$(git diff-tree --no-commit-id --name-only -r HEAD)
            - |
              if echo "$changedFiles" | grep -i 'packages'; then
                export UPDATE_BUILD_STATUS_PACKAGES_BUILD=true
                echo "Commit contains the changes for packages folder, hence updating the build status for commit"
              else
                echo "Commit doesn't contains the changes for packages folder, hence skipping"
              fi
            - popd
          onExecute:
            - pushd "$res_packagesGit_resourcePath"
            - git checkout {{gitBranch}}
            - export NODE_OPTIONS=--max-old-space-size=4096
            # nx support affected command that support running command on only changes https://blog.nrwl.io/using-nx-affected-on-ci-d3d2686295a0
            # On development branches run only affected while on master run eveyrthing https://nx.dev/ci/monorepo-ci-gitlab
            # Once those are configured, below logic should be changed
            - npm run build:packages
            - npm run lint:packages;
            - npm run test:packages;
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh;
            - sonar_storeCache packages;
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - export PACKAGES="amqp-client cache cloud configuration core data-access-layer decorators errors http-client http-server internal-clients logger metadata microservice redis scm-external-clients templates utility validators"
            - |
                for package in ${PACKAGES}; do
                  save_tests $res_packagesGit_resourcePath/packages/${package}/${package}-unit.xml
                done
            - stepCommons_on_complete

      - name: packages_sonar_scan
        type: Bash
        configuration:
          condition: 'QUICK_MODE == "false"'
          affinityGroup: packages
          integrations:
            - name: entplus_deployer
            - name: sonar_jfrog_info
          inputResources:
            - name: packagesGit
              trigger: false
          inputSteps:
            - name: packages_build
          environmentVariables:
            SONAR_PROJECT_KEY: 'pipelines_packages'
            SONAR_PROJECT_BASE_DIR: './packages'
            SONAR_QUALITYGATE_WAIT: 'false'
            SONAR_ADDITIONAL_OPTIONS: '-X'
            RUN_SONAR: 'true'
          runtime:
            type: image
            image:
              custom:
                registry: entplus_deployer
                sourceRepository: docker-staging-local
                name: docker.jfrog.io/sonar-scanner
                tag: ${SONAR_DOCKER_TAG:-latest}
        execution:
          onStart:
            - source ${res_packagesGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
            - on_start
          onExecute:
            - on_execute
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: api_quality
        type: Bash
        configuration:
          condition: 'QUICK_MODE == "false"'
          affinityGroup: api
          integrations:
            - name: entplus_deployer
          inputResources:
            - name: apiGit
              <<: *git_resource_trigger_condition
          inputSteps:
            - name: trigger_controlplane_builds
          runtime:
            type: image
            image:
              auto:
                language: node
                versions:
                  - "16.10.0"
        execution:
          onStart:
            - source ${res_apiGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_build_npm.sh
            - pushd $res_apiGit_resourcePath
            - on_start
          onExecute:
            - export NODE_OPTIONS=--max-old-space-size=4096
            - pushd $res_apiGit_resourcePath;
            - npm config set registry ${npmRegistry}
            - export RT_API_KEY="${int_entplus_deployer_apikey}"
            - export RT_USER="${int_entplus_deployer_user}"
            - export RT_URL="${int_entplus_deployer_url}"
            - cp ${res_apiGit_resourcePath}/build/ci/npm_installer.sh ./
            - ./npm_installer.sh
            - npm run build:packages;
            - pushd $res_apiGit_resourcePath;
            - npm run build:nodepool-client;
            - npm run lint:api;
            - npm run test:api;
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
            - sonar_storeCache services/api;
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - save_tests $res_apiGit_resourcePath/services/api/api-unit.xml
            - stepCommons_on_complete

      - name: api_sonar_scan
        type: Bash
        configuration:
          condition: 'QUICK_MODE == "false"'
          affinityGroup: api
          integrations:
            - name: entplus_deployer
            - name: sonar_jfrog_info
          inputResources:
            - name: apiGit
              trigger: false
          inputSteps:
            - name: api_quality
          environmentVariables:
            SONAR_PROJECT_KEY: 'pipelines_api'
            SONAR_PROJECT_BASE_DIR: './services/api'
            SONAR_QUALITYGATE_WAIT: 'false'
            SONAR_ADDITIONAL_OPTIONS: '-X'
            RUN_SONAR: 'true'
          runtime:
            type: image
            image:
              custom:
                registry: entplus_deployer
                sourceRepository: docker-staging-local
                name: docker.jfrog.io/sonar-scanner
                tag: ${SONAR_DOCKER_TAG:-latest}
        execution:
          onStart:
            - source ${res_apiGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
            - on_start
          onExecute:
            - on_execute
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: inst_build
        type: Bash
        configuration:
          <<: *app_build_node_pool
          environmentVariables:
            FORCE_RUN: 'true'
          integrations:
            - name: entplus_deployer
            - name: entplus_jfrog_io_docker
          inputResources:
            - name: installerGit
              <<: *git_resource_trigger_condition
            - name: machineImageJSON_fs
            - name: docker_fs
            - name: dockerCompose_fs
            - name: curl_tar_fs
            - name: curl_rpm_fs
            - name: ootbExtensionsJSONFS
            - name: installerBaseImage
            - name: node16BuildImage
          inputSteps:
            - name: trigger_controlplane_builds
        execution:
          onStart:
            - source ${res_installerGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_build_npm.sh
            - stepCommons_load_script build/ci/pipelines_build_docker.sh
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
            - add_run_variables RT_REPO="npm-virtual"
            - pushd $res_installerGit_resourcePath/
            - add_run_variables RELEASE_VERSION=$( ./normalizeReleaseVersion.sh {{gitBranch}} )
            - pushd installer
            - on_start
            - add_run_variables BUILD_NUMBER=$JFROG_CLI_BUILD_NUMBER
            - export installerImageName="entplus.jfrog.io/${RT_DOCKER_REPO}/jfrog/pipelines-installer"
            - export nativeBuildName=tar-${JFROG_CLI_BUILD_NAME}
            - debBuildName=deb-${JFROG_CLI_BUILD_NAME}
            - rpmBuildName=rpm-${JFROG_CLI_BUILD_NAME}
          onExecute:
            - pushd $res_installerGit_resourcePath/installer
            - echo "validating db tables file list"
            - $res_installerGit_resourcePath/installer/scripts/tests/db-tables-file-list-check.sh $res_installerGit_resourcePath/installer/scripts/schema/tables
            - mkdir -p bin dependencies/x86_64/zip/
            - tar zxvf ${res_docker_fs_resourcePath}/docker-${dockerVersion}.tgz -C dependencies/x86_64/zip/
            - cp -vr $res_dockerCompose_fs_resourcePath/installer/docker/docker-compose-${dockerComposeVersion} dependencies/x86_64/bin/
            - mv dependencies/x86_64/bin/docker-compose-${dockerComposeVersion} dependencies/x86_64/bin/docker-compose
            - chmod 555 dependencies/x86_64/bin/docker-compose
            - mv $res_curl_tar_fs_resourcePath/curl/curl/7.74.0/curl-7.74.0.tar.gz dependencies/x86_64/deb/
            - mv $res_curl_rpm_fs_resourcePath/installer/curl/curl-7.29.0-59.el7.x86_64.rpm dependencies/x86_64/yum/
            - export PIPELINES_VERSION=$RELEASE_VERSION
            - echo "Release version is ${RELEASE_VERSION}"
            - dockerTag="$RELEASE_VERSION"
            - tarFilename="pipelines-$RELEASE_VERSION.tar.gz"
            - rpmFilename="pipelines-$RELEASE_VERSION.rpm"
            - debFilename="pipelines-$RELEASE_VERSION.deb"
            - jfrog rt dl --flat pipelines-artifacts/imagebuilds/base-images/${baseMachineImageVersion}-buildplaneImages.json
            - cp -vr ${baseMachineImageVersion}-buildplaneImages.json ./bin/buildplaneImages.json
            - cp -vr $res_ootbExtensionsJSONFS_resourcePath/${buildPlaneVersion}-ootb-extensions.json ./bin/ootb-extensions.json
            - echo $buildPlaneVersion > bin/buildplaneVersion.txt
            - echo $RELEASE_VERSION > bin/controlplaneVersion.txt
            - sudo chmod 1777 /tmp
            - sudo apt-get update --allow-unauthenticated
            - sudo apt-get install -y rsync
            - |
              RT_URL=$repo21 \
              RT_USER=$int_entplus_deployer_user \
              RT_API_KEY=$int_entplus_deployer_apikey \
              RT_REGISTRY=entplus.jfrog.io/${RT_DOCKER_REPO} \
              IMG_NAME=$installerImageName \
              IMG_TAG=$RELEASE_VERSION \
              MICRO_BUILD_IMAGE=$res_node16BuildImage_imageName:$res_node16BuildImage_imageTag \
              BASE_RUN_IMAGE=$res_installerBaseImage_imageName:$res_installerBaseImage_imageTag \
              ./build.sh "${res_installerGit_resourcePath}"
            - echo "Generated Artifacts"
            - ls -atlh bin/
            - echo "Successfully built all artifacts"
            - popd
            - pushd $res_installerGit_resourcePath/installer
            - jfrog rt upload bin/$tarFilename pipelines-installers/installer/$tarFilename --build-name=${nativeBuildName} --build-number=${JFROG_CLI_BUILD_NUMBER}
            - jfrog rt upload bin/$debFilename deb-snapshot-local/pool/jfrog-pipelines/$debFilename --deb xenial/main/all --build-name=${debBuildName} --build-number=${JFROG_CLI_BUILD_NUMBER}
            - jfrog rt upload bin/$rpmFilename yum-snapshot-local/jfrog-pipelines/$rpmFilename --build-name=${rpmBuildName} --build-number=${JFROG_CLI_BUILD_NUMBER}
            - jfrog rt build-collect-env ${nativeBuildName} ${JFROG_CLI_BUILD_NUMBER}
            - jfrog rt build-collect-env ${debBuildName} ${JFROG_CLI_BUILD_NUMBER}
            - jfrog rt build-collect-env ${rpmBuildName} ${JFROG_CLI_BUILD_NUMBER}
            - jfrog rt build-add-git ${nativeBuildName} ${JFROG_CLI_BUILD_NUMBER}
            - jfrog rt build-add-git ${debBuildName} ${JFROG_CLI_BUILD_NUMBER}
            - jfrog rt build-add-git ${rpmBuildName} ${JFROG_CLI_BUILD_NUMBER}
            - jfrog rt build-publish ${nativeBuildName} ${JFROG_CLI_BUILD_NUMBER}
            - jfrog rt build-publish ${debBuildName} ${JFROG_CLI_BUILD_NUMBER}
            - jfrog rt build-publish ${rpmBuildName} ${JFROG_CLI_BUILD_NUMBER}
            - source "${res_installerGit_resourcePath}/build/ci/xray_violation_handler.sh"
            - run_xray_security_scan "${JFROG_CLI_BUILD_NAME}" "${JFROG_CLI_BUILD_NUMBER}" || echo "failed to run xray scan"
            - run_xray_security_scan "${debBuildName}" "${JFROG_CLI_BUILD_NUMBER}" || echo "failed to run xray scan"
            - run_xray_security_scan "${rpmBuildName}" "${JFROG_CLI_BUILD_NUMBER}" || echo "failed to run xray scan"
            - run_xray_security_scan "${nativeBuildName}" "${JFROG_CLI_BUILD_NUMBER}" || echo "failed to run xray scan"
            - popd
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
            - echo "Cleaning up stale docker images"
            - docker rmi $(docker images -f "dangling=true" -q) || true
          onComplete:
            - stepCommons_on_complete

      - name: inst_test
        type: Bash
        configuration:
          condition: 'QUICK_MODE == "false"'
          affinityGroup: installer
          integrations:
            - name: entplus_deployer
          inputResources:
            - name: installerGit
              <<: *git_resource_trigger_condition
          inputSteps:
            - name: inst_build
          runtime:
            type: image
            image:
              auto:
                language: node
                versions:
                  - 14
        execution:
          onStart:
            - source ${res_installerGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - pushd $res_installerGit_resourcePath/installer
            - jfrog rt npm-config --server-id-resolve entplus_deployer --repo-resolve npm-virtual
            - jfrog rt npm-install
            - npm test -- --coverage
            # Sonar Logic Begin
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
            - sonar_storeCache installer
            # Sonar Logic End
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: inst_sonar_scan
        type: Bash
        configuration:
          condition: 'QUICK_MODE == "false"'
          affinityGroup: installer
          integrations:
            - name: entplus_deployer
            - name: sonar_jfrog_info
          inputResources:
            - name: installerGit
              trigger: false
          inputSteps:
            - name: inst_test
          environmentVariables:
            SONAR_PROJECT_KEY: 'pipelines_installer'
            SONAR_PROJECT_BASE_DIR: './installer'
            SONAR_QUALITYGATE_WAIT: 'false'
            SONAR_ADDITIONAL_OPTIONS: '-X'
            RUN_SONAR: 'true'
          runtime:
            type: image
            image:
              custom:
                registry: entplus_deployer
                sourceRepository: docker-staging-local
                name: docker.jfrog.io/sonar-scanner
                tag: ${SONAR_DOCKER_TAG:-latest}
        execution:
          onStart:
            - source ${res_installerGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
            - on_start
          onExecute:
            - on_execute
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

            
      - name: template_build
        type: Bash
        configuration:
          nodePool: pipelines_u20_t3small
          affinityGroup: template
          integrations:
            - name: entplus_deployer
          inputResources:
            - name: cpGit
              <<: *git_resource_trigger_condition
          inputSteps:
            - name: trigger_controlplane_builds
          outputResources:
            - name: templateFS
          runtime:
            type: image
            image:
              auto:
                language: go
                versions:
                  - {{ .Values.goBuildVersion }}
        execution:
          onStart:
            - source ${res_cpGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_build_go.sh
            - pushd $res_cpGit_resourcePath
            - add_run_variables RELEASE_VERSION=$( ./normalizeReleaseVersion.sh {{gitBranch}} )
            - pushd template
            - on_start
            - go version
            - echo "Release version is ${RELEASE_VERSION}"
            - make install
            - golangci-lint run || true
            - make test
            - make ARGS="-ldflags \"-X main.version='$RELEASE_VERSION'\"" build
            - BIN_FILENAME="pipelines-template-$RELEASE_VERSION-linux-amd64"
            - jfrog rt upload ${BIN_FILENAME} $templateTarget/$BIN_FILENAME --target-props "vcs.branch={{gitBranch}}"
            - BIN_FILENAME="pipelines-template-$RELEASE_VERSION-linux-arm64"
            - jfrog rt upload ${BIN_FILENAME} $templateTarget/$BIN_FILENAME --target-props "vcs.branch={{gitBranch}}"
            - jfrog rt build-collect-env
            - jfrog rt build-add-git
            - jfrog rt build-publish
            - add_run_variables TEMPLATE_BUILD_NUMBER=$JFROG_CLI_BUILD_NUMBER
            - add_run_variables TEMPLATE_BUILD_NAME=$JFROG_CLI_BUILD_NAME
            - popd
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete
      
      - name: template_xray_scan
        type: Bash
        configuration:
          condition: 'XRAY_ENABLED == "true"'
          nodePool: pipelines_u20_t3small
          inputSteps:
            - name: template_build
          inputResources:
            - name: templateGit
              trigger: false
          integrations:
            - name: entplus_deployer
            - name: entplus_jfrog_io_docker
        execution:
          onExecute:
            - source "${res_templateGit_resourcePath}/build/ci/xray_violation_handler.sh"
            - run_xray_security_scan "${TEMPLATE_BUILD_NAME}" "${TEMPLATE_BUILD_NUMBER}" || echo "failed to run xray scan"

      - name: micro_build
        type: Bash
        configuration:
          <<: *app_build_node_pool
          runtime:
            type: image
            image:
              auto:
                language: node
                versions:
                  - "16.10.0"
          integrations:
            - name: entplus_deployer
          inputSteps:
            - name: template_build
          inputResources:
            - name: microGit
              <<: *git_resource_trigger_condition
            - name: ootbExtensionsFS_cp
            - name: templateFS
              trigger: false
            - name: node16MicroRunImage
            - name: node16BuildImage
        execution:
          onStart:
            - source ${res_microGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - pushd $res_microGit_resourcePath
            - add_run_variables RELEASE_VERSION=$( ./normalizeReleaseVersion.sh {{gitBranch}} )
            - echo "Release version is ${RELEASE_VERSION}"
            - stepCommons_load_script build/ci/pipelines_build_docker.sh
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
            - on_start
            - add_run_variables BUILD_NUMBER=$JFROG_CLI_BUILD_NUMBER
            - export microImageName="entplus.jfrog.io/${RT_DOCKER_REPO}/jfrog/pipelines-micro"
          onExecute:       
            - pushd $res_microGit_resourcePath
            - export NODE_OPTIONS=--max-old-space-size=4096
            - pushd $res_microGit_resourcePath/micro
            - mkdir -p bin
            - cp -vr $res_ootbExtensionsFS_cp_resourcePath/extensions-$buildPlaneVersion.tar.gz bin/extensions.tar.gz
            - cp -vr $res_templateFS_resourcePath/pipelines-template-$RELEASE_VERSION-linux-amd64 bin/pipelines-template-linux-amd64
            - if [[ "${ARM_BUILD_ENABLED}" == "true" ]]; then cp -vr $res_templateFS_resourcePath/pipelines-template-$RELEASE_VERSION-linux-arm64 bin/pipelines-template-linux-arm64 ; fi; 
            - chmod +x bin/pipelines-template*
            - |
              RT_SERVER=server \
              RT_URL=$repo21 \
              RT_USER=$int_entplus_deployer_user \
              RT_API_KEY=$int_entplus_deployer_apikey \
              IMG_NAME=$microImageName \
              PIPELINES_CORE_VERSION=$PIPELINES_CORE_VERSION \
              IMG_TAG=$RELEASE_VERSION \
              RT_REGISTRY=entplus.jfrog.io/${RT_DOCKER_REPO} \
              MICRO_BUILD_IMAGE=$res_node16BuildImage_imageName:$res_node16BuildImage_imageTag \
              BASE_RUN_IMAGE=$res_node16MicroRunImage_imageName:$res_node16MicroRunImage_imageTag \
              ./buildMicro.sh "${res_microGit_resourcePath}"
            - add_run_variables MICRO_BUILD_NUMBER=$JFROG_CLI_BUILD_NUMBER
            - add_run_variables MICRO_BUILD_NAME=$JFROG_CLI_BUILD_NAME
            - popd
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: micro_xray_scan
        type: Bash
        configuration:
          condition: 'XRAY_ENABLED == "true"'
          nodePool: pipelines_u20_t3small
          inputSteps:
            - name: micro_build
          inputResources:
            - name: microGit
              trigger: false
          integrations:
            - name: entplus_deployer
            - name: entplus_jfrog_io_docker
        execution:
          onExecute:
            - source "${res_microGit_resourcePath}/build/ci/xray_violation_handler.sh"
            - run_xray_security_scan "${MICRO_BUILD_NAME}" "${MICRO_BUILD_NUMBER}" || echo "failed to run xray scan"

      - name: micro_quality
        type: Bash
        configuration:
          condition: 'QUICK_MODE == "false"'
          affinityGroup: micro
          runtime:
            type: image
            image:
              auto:
                language: node
                versions:
                  - "16.10.0"
          integrations:
            - name: entplus_deployer
          inputSteps:
            - name: template_build
          inputResources:
            - name: microGit
              <<: *git_resource_trigger_condition
            - name: templateFS
              trigger: false
        execution:
          onStart:
            - source ${res_microGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_build_npm.sh
            - on_start
          onExecute:
            - pushd $res_microGit_resourcePath
            - export NODE_OPTIONS=--max-old-space-size=4096
            - npm config set registry ${npmRegistry}
            - export RT_API_KEY="${int_entplus_deployer_apikey}"
            - export RT_USER="${int_entplus_deployer_user}"
            - export RT_URL="${int_entplus_deployer_url}"
            - cp ${res_microGit_resourcePath}/build/ci/npm_installer.sh ./
            - ./npm_installer.sh
            - npm run build:packages;
            - npm run lint -w micro;
            - npm run test -w micro;
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh;
            - sonar_storeCache micro;
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - save_tests $res_microGit_resourcePath/micro/micro-unit.xml
            - stepCommons_on_complete

      - name: mstest_setup
        type: Bash
        configuration:
          condition: 'QUICK_MODE == "false"'
          affinityGroup: msTest
          runtime:
            type: image
            image:
              auto:
                language: node
                versions:
                  - "16.10.0"
          integrations:
            - name: entplus_deployer
          inputSteps:
            - name: template_build
          inputResources:
            - name: bddGit_pipelineSync
              <<: *git_resource_trigger_condition
            - name: templateFS
              trigger: false
        execution:
          onStart:
            - source ${res_bddGit_pipelineSync_resourcePath}/build/ci/pipelines_step_setup.sh
            - npm config set registry ${npmRegistry}
            - pushd "$res_bddGit_pipelineSync_resourcePath"
            - add_run_variables RELEASE_VERSION=$( ./normalizeReleaseVersion.sh {{gitBranch}} )
            - export RT_API_KEY="${int_entplus_deployer_apikey}"
            - export RT_USER="${int_entplus_deployer_user}"
            - export RT_URL="${int_entplus_deployer_url}"
            - cp ${res_bddGit_pipelineSync_resourcePath}/build/ci/npm_installer.sh ./
            - ./npm_installer.sh
            - export NODE_OPTIONS=--max-old-space-size=4096
            - cp -vr $res_templateFS_resourcePath/pipelines-template-$RELEASE_VERSION-linux-amd64 template/template && chmod +x template/template
          onExecute:
            - npm run build:packages
            - npm run lint -w tools/ms-testing-library
            - npm run build -w tools/ms-testing-library
            - npm run lint -w bdd
            - cp -R . $shared_workspace
          onSuccess:            
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: mstest_pipelines_sync
        type: Bash
        configuration:
          condition: 'QUICK_MODE == "false"'
          affinityGroup: msTest
          inputSteps:
            - name: template_build
            - name: mstest_setup
          integrations:
            - name: entplus_deployer
          inputResources:
            - name: bddGit_pipelineSync
              <<: *git_resource_trigger_condition
          runtime:
            type: image
            image:
              auto:
                language: node
                versions:
                  - 16
        execution:
          onStart:
            - source ${res_bddGit_pipelineSync_resourcePath}/build/ci/pipelines_step_setup.sh
            - export NODE_OPTIONS=--max-old-space-size=4096
            - working_dir=/tmp/workspace_${steplet_number}
            - mkdir -p ${working_dir}
            - cp -r $shared_workspace/* ${working_dir}
            - source ${working_dir}/build/ci/pipelines_step_setup.sh
          onExecute:
            - pushd ${working_dir}/bdd
            - npm run bdd:pipelineSync --tags="@ConfigFolder or @NonSCM or @MultiBranch or @Update or @WorkFlow or @Resource_set or @Templates"
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: mstest_pipeline_sync_nativeStep
        type: Matrix
        stepMode: Bash
        configuration:
          condition: 'QUICK_MODE == "false" &&  Enabled_Native_Steps_MSTest == "true"'
          affinityGroup: msTest
          inputSteps:
            - name: template_build
            - name: mstest_setup
          integrations:
            - name: entplus_deployer
          inputResources:
            - name: bddGit_pipelineSync
              <<: *git_resource_trigger_condition
          runtime:
            type: image
            image:
              auto:
                language: node
                versions:
                  - 16
        stepletMultipliers:
          environmentVariables:
            - listOfTags: "@NativeStep_set1"
            - listOfTags: "@NativeStep_set2"
            - listOfTags: "@NativeStep_set3"
            - listOfTags: "@NativeStep_set4"
            - listOfTags: "@NativeStep_set5"
            - listOfTags: "@NativeStep_set6"
        execution:
          onStart:
            - source ${res_bddGit_pipelineSync_resourcePath}/build/ci/pipelines_step_setup.sh
            - export NODE_OPTIONS=--max-old-space-size=4096
            - working_dir=/tmp/workspace_${steplet_number}
            - mkdir -p ${working_dir}
            - cp -r $shared_workspace/* ${working_dir}
            - source ${working_dir}/build/ci/pipelines_step_setup.sh
          onExecute:
            - pushd ${working_dir}/bdd
            - npm run bdd:pipelineSync --tags="$listOfTags"
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: mstest_cron
        type: Bash
        configuration:
          condition: 'QUICK_MODE == "false"'
          integrations:
            - name: entplus_deployer
          inputResources:
            - name: bddGit
              <<: *git_resource_trigger_condition
            - name: templateFS
          inputSteps:
            - name: template_build
          runtime:
            type: image
            image:
              auto:
                language: node
                versions:
                  - 16
        execution:
          onStart:
            - source ${res_bddGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - npm config set registry ${npmRegistry}
            - curl -u"${int_entplus_deployer_user}":"${int_entplus_deployer_apikey}" "${int_entplus_deployer_url}/api/npm/auth" >> ~/.npmrc
            - stepCommons_load_script build/ci/pipelines_build_npm.sh
            - pushd $res_bddGit_resourcePath
            - add_run_variables RELEASE_VERSION=$( ./normalizeReleaseVersion.sh {{gitBranch}} )
            - echo "Release version is ${RELEASE_VERSION}"
            - npm ci --no-audit --no-fund --ignore-scripts
            - npm run build:packages
            - npm run build -w tools/ms-testing-library
            - on_start
          onExecute:
            - pushd $res_bddGit_resourcePath
            - cp -vr $res_templateFS_resourcePath/pipelines-template-$RELEASE_VERSION-linux-amd64 template/template
            - chmod +x template/template
            - npm run build -w tools/ms-testing-library
            - npm run build:micro
            - pushd bdd
            - npm run bdd:cron
            - popd
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: mstest_hookhandler
        type: Bash
        configuration:
          condition: 'QUICK_MODE == "false"'
          integrations:
            - name: entplus_deployer
          inputSteps:
            - name: template_build
          inputResources:
            - name: bddGit
              <<: *git_resource_trigger_condition
            - name: templateFS
          runtime:
            type: image
            image:
              auto:
                language: node
                versions:
                  - 16
        execution:
          onStart:
            - source ${res_bddGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - npm config set registry ${npmRegistry}
            - curl -u"${int_entplus_deployer_user}":"${int_entplus_deployer_apikey}" "${int_entplus_deployer_url}/api/npm/auth" >> ~/.npmrc
            - stepCommons_load_script build/ci/pipelines_build_npm.sh
            - pushd $res_bddGit_resourcePath
            - add_run_variables RELEASE_VERSION=$( ./normalizeReleaseVersion.sh {{gitBranch}} )
            - echo "Release version is ${RELEASE_VERSION}"
            - npm ci --no-audit --no-fund --ignore-scripts
            - npm run build:packages
            - on_start
          onExecute:
            - pushd $res_bddGit_resourcePath
            - cp -vr $res_templateFS_resourcePath/pipelines-template-$RELEASE_VERSION-linux-amd64 template/template
            - chmod +x template/template
            - npm run build -w tools/ms-testing-library
            - npm run build:micro
            - pushd bdd
            - npm run bdd:hookHandler
            - popd
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: micro_sonar_scan
        type: Bash
        configuration:
          condition: 'QUICK_MODE == "false"'
          affinityGroup: micro
          integrations:
            - name: entplus_deployer
            - name: sonar_jfrog_info
          inputResources:
            - name: microGit
              trigger: false
          inputSteps:
            - name: micro_quality
          environmentVariables:
            SONAR_PROJECT_KEY: 'pipelines_micro'
            SONAR_PROJECT_BASE_DIR: './micro/'
            SONAR_QUALITYGATE_WAIT: 'false'
            SONAR_ADDITIONAL_OPTIONS: '-X'
            RUN_SONAR: 'true'
          runtime:
            type: image
            image:
              custom:
                registry: entplus_deployer
                sourceRepository: docker-staging-local
                name: docker.jfrog.io/sonar-scanner
                tag: ${SONAR_DOCKER_TAG:-latest}
        execution:
          onStart:
            - source ${res_microGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
            - on_start
          onExecute:
            - on_execute
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: www_build
        type: Bash
        configuration:
          <<: *app_build_node_pool
          runtime:
            type: image
            image:
              auto:
                language: node
                versions:
                  - "16.10.0"
          integrations:
            - name: entplus_deployer
          inputResources:
            - name: wwwGit
              <<: *git_resource_trigger_condition
            - name: node16MicroRunImage
            - name: node16BuildImage
          inputSteps:
            - name: trigger_controlplane_builds
        execution:
          onStart:
            - source ${res_wwwGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - pushd $res_wwwGit_resourcePath
            - add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh {{gitBranch}})
            - stepCommons_load_script build/ci/pipelines_build_docker.sh
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
            - on_start
            - add_run_variables BUILD_NUMBER=$JFROG_CLI_BUILD_NUMBER
            - export wwwImageName="entplus.jfrog.io/${RT_DOCKER_REPO}/jfrog/pipelines-www"
          onExecute:
            - pushd $res_wwwGit_resourcePath/services/www
            - |
              RT_SERVER=server \
              RT_URL=$repo21 \
              RT_USER=$int_entplus_deployer_user \
              RT_API_KEY=$int_entplus_deployer_apikey \
              IMG_NAME=$wwwImageName \
              IMG_TAG=$RELEASE_VERSION \
              RT_REGISTRY=entplus.jfrog.io/${RT_DOCKER_REPO} \
              MICRO_BUILD_IMAGE=$res_node16BuildImage_imageName:$res_node16BuildImage_imageTag \
              BASE_RUN_IMAGE=$res_node16MicroRunImage_imageName:$res_node16MicroRunImage_imageTag \
              ./buildWww.sh "${res_wwwGit_resourcePath}"
            - add_run_variables WWW_BUILD_NUMBER=$JFROG_CLI_BUILD_NUMBER
            - add_run_variables WWW_BUILD_NAME=$JFROG_CLI_BUILD_NAME
            - popd
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: runService_build
        type: Bash
        configuration:
          <<: *app_build_node_pool
          runtime:
            type: image
            image:
              custom:
                name: releases-docker.jfrog.io/jfrog/pipelines-u20node
                tag: 16.10.0
                options: '--net=host'
          integrations:
            - name: entplus_deployer
          inputResources:
            - name: runServiceGit
              <<: *git_resource_trigger_condition
            - name: node16BuildImage
            - name: node16MicroRunImage
          inputSteps:
            - name: trigger_controlplane_builds
        execution:
          onStart:
            - source ${res_runServiceGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - pushd $res_runServiceGit_resourcePath
            - add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh {{gitBranch}})
            - stepCommons_load_script build/ci/pipelines_build_docker.sh
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
            - pushd $res_runServiceGit_resourcePath/services/run-service
            - on_start
            - add_run_variables BUILD_NUMBER=$JFROG_CLI_BUILD_NUMBER
            - export runServiceImageName="entplus.jfrog.io/${RT_DOCKER_REPO}/jfrog/pipelines-run-service"
          onExecute:
            - pushd $res_runServiceGit_resourcePath
            - export NODE_OPTIONS=--max-old-space-size=4096
            - pushd $res_runServiceGit_resourcePath/services/run-service
            - mkdir -p bin
            - echo -n $buildPlaneVersion > ./bin/buildplaneVersion.txt
            - echo "Release version is ${RELEASE_VERSION}"
            - |
              RT_SERVER=server \
              RT_URL=$repo21 \
              RT_USER=$int_entplus_deployer_user \
              RT_API_KEY=$int_entplus_deployer_apikey \
              IMG_NAME=$runServiceImageName \
              IMG_TAG=$RELEASE_VERSION \
              RT_REGISTRY=entplus.jfrog.io/${RT_DOCKER_REPO} \
              NODE_BUILD_IMAGE=$res_node16BuildImage_imageName:$res_node16BuildImage_imageTag \
              BASE_RUN_IMAGE=$res_node16MicroRunImage_imageName:$res_node16MicroRunImage_imageTag \
              ./build.sh "${res_runServiceGit_resourcePath}"
            - popd
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: runService_quality
        type: Bash
        configuration:
          condition: 'QUICK_MODE == "false"'
          affinityGroup: runService
          runtime:
            type: image
            image:
              custom:
                name: releases-docker.jfrog.io/jfrog/pipelines-u20node
                tag: 16.10.0
                options: '--net=host'
          integrations:
            - name: entplus_deployer
          inputResources:
            - name: runServiceGit
              <<: *git_resource_trigger_condition
          inputSteps:
            - name: trigger_controlplane_builds
        execution:
          onStart:
            - source ${res_runServiceGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_build_npm.sh
            - pushd $res_runServiceGit_resourcePath
            - add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh {{gitBranch}})
            - stepCommons_load_script build/ci/pipelines_build_docker.sh
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
            - pushd $res_runServiceGit_resourcePath/services/run-service
            - on_start
            - add_run_variables BUILD_NUMBER=$JFROG_CLI_BUILD_NUMBER
            - export runServiceImageName="entplus.jfrog.io/${RT_DOCKER_REPO}/jfrog/pipelines-run-service"
          onExecute:
            - pushd $res_runServiceGit_resourcePath
            - export NODE_OPTIONS=--max-old-space-size=4096
            - npm config set registry ${npmRegistry}
            - export RT_API_KEY="${int_entplus_deployer_apikey}"
            - export RT_USER="${int_entplus_deployer_user}"
            - export RT_URL="${int_entplus_deployer_url}"
            - cp ${res_runServiceGit_resourcePath}/build/ci/npm_installer.sh ./
            - ./npm_installer.sh
            - npm run build:packages
            - npm run build:tools
            - npm run build:run
            - npm run lint:run;
            - npm run test:run;
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh;
            - sonar_storeCache services/run-service;
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - save_tests $res_runServiceGit_resourcePath/services/run-service/run-service-unit.xml
            - save_tests $res_runServiceGit_resourcePath/services/run-service/run-service-bdd.xml
            - stepCommons_on_complete

      - name: runService_sonar_scan
        type: Bash
        configuration:
          condition: 'QUICK_MODE == "false"'
          affinityGroup: runService
          integrations:
            - name: entplus_deployer
            - name: sonar_jfrog_info
          inputResources:
            - name: runServiceGit
              trigger: false
          inputSteps:
            - name: runService_quality
          environmentVariables:
            SONAR_PROJECT_KEY: 'pipelines_run-service'
            SONAR_PROJECT_BASE_DIR: './services/run-service'
            SONAR_QUALITYGATE_WAIT: 'false'
            SONAR_ADDITIONAL_OPTIONS: '-X'
            RUN_SONAR: 'true'
          runtime:
            type: image
            image:
              custom:
                registry: entplus_deployer
                sourceRepository: docker-staging-local
                name: docker.jfrog.io/sonar-scanner
                tag: ${SONAR_DOCKER_TAG:-latest}
        execution:
          onStart:
            - source ${res_runServiceGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
            - on_start
          onExecute:
            - on_execute
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: logService_build
        type: Bash
        configuration:
          <<: *app_build_node_pool
          runtime:
            type: image
            image:
              custom:
                name: releases-docker.jfrog.io/jfrog/pipelines-u20node
                tag: 16.10.0
                options: '--net=host'
          integrations:
            - name: entplus_deployer
          inputResources:
            - name: logServiceGit
              <<: *git_resource_trigger_condition
            - name: node16BuildImage
            - name: node16MicroRunImage
          inputSteps:
            - name: trigger_controlplane_builds
        execution:
          onStart:
            - source ${res_logServiceGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - pushd $res_logServiceGit_resourcePath
            - add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh {{gitBranch}})
            - stepCommons_load_script build/ci/pipelines_build_docker.sh
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
            - pushd $res_logServiceGit_resourcePath/services/log-service
            - on_start
            - add_run_variables BUILD_NUMBER=$JFROG_CLI_BUILD_NUMBER
            - export logServiceImageName="entplus.jfrog.io/${RT_DOCKER_REPO}/jfrog/pipelines-log-service"
          onExecute:
            - export NODE_OPTIONS=--max-old-space-size=4096
            - pushd $res_logServiceGit_resourcePath/services/log-service
            - mkdir -p bin
            - echo -n $buildPlaneVersion > ./bin/buildplaneVersion.txt
            - echo "Release version is ${RELEASE_VERSION}"
            - |
              RT_SERVER=server \
              RT_URL=$repo21 \
              RT_USER=$int_entplus_deployer_user \
              RT_API_KEY=$int_entplus_deployer_apikey \
              IMG_NAME=$logServiceImageName \
              IMG_TAG=$RELEASE_VERSION \
              RT_REGISTRY=entplus.jfrog.io/${RT_DOCKER_REPO} \
              NODE_BUILD_IMAGE=$res_node16BuildImage_imageName:$res_node16BuildImage_imageTag \
              BASE_RUN_IMAGE=$res_node16MicroRunImage_imageName:$res_node16MicroRunImage_imageTag \
              ./build.sh "${res_logServiceGit_resourcePath}"
            - popd
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: logService_quality
        type: Bash
        configuration:
          condition: 'QUICK_MODE == "false"'
          affinityGroup: logService
          runtime:
            type: image
            image:
              custom:
                name: releases-docker.jfrog.io/jfrog/pipelines-u20node
                tag: 16.10.0
                options: '--net=host'
          integrations:
            - name: entplus_deployer
          inputResources:
            - name: logServiceGit
              <<: *git_resource_trigger_condition
          inputSteps:
            - name: trigger_controlplane_builds
        execution:
          onStart:
            - source ${res_logServiceGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_build_npm.sh
            - pushd $res_logServiceGit_resourcePath
            - add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh {{gitBranch}})
            - stepCommons_load_script build/ci/pipelines_build_docker.sh
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
            - pushd $res_logServiceGit_resourcePath/services/log-service
            - on_start
            - add_run_variables BUILD_NUMBER=$JFROG_CLI_BUILD_NUMBER
            - export logServiceImageName="entplus.jfrog.io/${RT_DOCKER_REPO}/jfrog/pipelines-log-service"
          onExecute:
            - pushd $res_logServiceGit_resourcePath
            - export NODE_OPTIONS=--max-old-space-size=4096
            - npm config set registry ${npmRegistry}
            - export RT_API_KEY="${int_entplus_deployer_apikey}"
            - export RT_USER="${int_entplus_deployer_user}"
            - export RT_URL="${int_entplus_deployer_url}"
            - cp ${res_logServiceGit_resourcePath}/build/ci/npm_installer.sh ./
            - ./npm_installer.sh
            - npm run build:packages;
            - npm run build -w tools/ms-testing-library;
            - npm run lint:log;
            - npm run test:log;
            - npm run bdd:log;
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh;
            - sonar_storeCache services/log-service;
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - save_tests $res_logServiceGit_resourcePath/services/log-service/log-service-unit.xml
            - stepCommons_on_complete
